using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Wind
{
    /**
     * <summary>Represents a 3D wind field of equal-size cube cells, each containing a wind vector and, optionally, 
     * a list of objects in that cell (must have HashObject script attached to them)
     * </summary>
     */
    [RequireComponent(typeof(Cells))]
    public class WindField : MonoBehaviour
    {
        //If true, factor in a global wind vector when getting wind from cells; this vector will also be the default wind vector for new cells,
        //and for getting wind info from a world position at which there is no cell (if false, the latter two values will be Vector3.zero)
        public bool useGlobalWind = true;
        public Vector3 globalWind; //the default global wind vector applied to all cells. 

        public bool addNoise = true; //If true, will add a direction generated by a Perlin noise function when getting wind from cells
        public bool useTimeOffset = true;
        public float noiseFrequency = 0.01f;
        public float noiseStrength = 1f;

        private Cells cells;
        private List<WindProducer> dynamicProducers;
        private float updateInterval = 0.2f;

        private void Start()
        {
            cells = GetComponent<Cells>();
            dynamicProducers = new List<WindProducer>();

            StartCoroutine(UpdateCells());
        }

        //Updates dynamic wind points for all cells in the wind field.
        private IEnumerator UpdateCells()
        {
            while (true)
            {
                cells.UpdateCells(dynamicProducers);
                yield return new WaitForSecondsRealtime(updateInterval);
            }
        }

        /*----PUBLIC FUNCTIONS----*/
        //Includes the given WindFieldPoint in the wind field: if dynamic, adds the point to the dynamic wind objects list and then to its corresponding cell;
        //if static, just adds the point to its cell (since static wind points are never updated, there is no need to keep track of them outside their cells) 
        public void Include(WindProducer windProducer)
        {
            if (windProducer.mode == WindProducerMode.Dynamic) dynamicProducers.Add(windProducer);
            AddToCell(windProducer.GetWindFieldPoints());
        }

        //Adds a given WindFieldPoint to the cell corresponding to its position.
        public void AddToCell(WindFieldPoint obj)
        {
            cells.AddToCell(obj);
        }

        //Adds given WindFieldPoints to their corresponding cells (creates new cell(s) if none exist at generated hash position(s))
        public void AddToCell(WindFieldPoint[] objs)
        {
            foreach (WindFieldPoint obj in objs) AddToCell(obj);
        }

        /*----GETTERS AND SETTERS----*/
        //Gets the wind vector at the given world position. If no cell exists at the given position, returns either (0, 0, 0) or the global wind vector, if using
        public Vector3 GetWind(Vector3 pos)
        {
            //If no root at this position, returns either the global wind vec or zero.
            Vector3 wind = useGlobalWind ? globalWind : Vector3.zero;

            if (addNoise)
            {
                Vector3 coords = pos;
                wind += DirectionalPerlin.Directional3D(coords, noiseFrequency, useTimeOffset ? Time.time : 0) * noiseStrength;
            }

            wind += cells.GetWind(pos);
            return wind;
        }

        public List<Cell> GetCells()
        {
            return cells.GetCells();
        }

        public float GetCellSize()
        {
            return cells.GetCellSize();
        }

        /*
        //Get the world position of the centre of the cell with the given hash key.
        public Vector3 GetCellWorldPositionCentre(WF_HashKey key)
        {
            Vector3Int[] k = key.GetKey();
            Vector3 worldPos = ((Vector3)k[0] * rootCellSize);
            float cellSize = rootCellSize / 2;

            for (int i = 1; i < k.Length; i++)
            {
                worldPos += (Vector3)k[i] * cellSize;
                cellSize /= 2;
            }

            //add half of deepest cell size in each dimension to get centre of deepest cell
            return worldPos + new Vector3(cellSize, cellSize, cellSize);
        }
        */

        /* DEBUG FUNCTIONS */
        //Returns the world position and size of all cells in the wind field. I can only see this being used as a debug/visualisation helper
        public List<Tuple<Vector3, float>> DEBUG_GetCellsWorldPosAndSize()
        {
            return cells.DEBUG_GetCellsWorldPosAndSize();
        }

        //Returns the world positions of the centre of each cell.
        public List<Vector3> DEBUG_GetCellWorldPositionsCentre()
        {
            return cells.DEBUG_GetCellWorldPositionsCentre();
        }

    }
}