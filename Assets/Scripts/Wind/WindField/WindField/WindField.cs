using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

//based on https://unionassets.com/blog/spatial-hashing-295
/**
 * <summary>Represents a 3D wind field of equal-size cube cells, each containing a wind vector and, optionally, 
 * a list of objects in that cell (must have HashObject script attached to them)
 * </summary>
 */
[RequireComponent(typeof(WF_Cells))]
public class WindField : MonoBehaviour
{
    [Range(0.1f, 100f)] public float rootCellSize = 1;
    public Vector3Int initNumRootCells;

    //If true, factor in a global wind vector when getting wind from cells; this vector will also be the default wind vector for new cells,
    //and for getting wind info from a world position at which there is no cell (if false, the latter two values will be Vector3.zero)
    public bool useGlobalWind = true;
    public Vector3 globalWind; //the default global wind vector applied to all cells. 

    //If true, will add a direction generated by a Perlin noise function to each cell.
    public bool addNoise = true;
    public bool useTimeOffset = true;
    public float noiseFrequency = 0.01f;
    public float noiseStrength = 1f;

    private WF_Cells cells;
    private List<WF_WindProducer> dynamicProducers;
    private float updateInterval = 0.2f;

    private void Start()
    {
        //create initial cells
        cells = GetComponent<WF_Cells>();
        //cells = new Dictionary<WF_HashKey, WF_Cell>(initNumRootCells.x * initNumRootCells.y * initNumRootCells.z);
        dynamicProducers = new List<WF_WindProducer>();

        Vector3Int halfNumCells = initNumRootCells / 2;
        for (int i = -halfNumCells.x; i < halfNumCells.x; i++)
        {
            for (int j = -halfNumCells.y; j < halfNumCells.y; j++)
            {
                for (int k = -halfNumCells.z; k < halfNumCells.z; k++)
                {
                    WF_WindPoint point = new WF_WindPoint
                    (
                        //new Vector3(i * rootCellSize, j * rootCellSize, k * rootCellSize) + new Vector3(Random.Range(0, rootCellSize), Random.Range(0, rootCellSize), Random.Range(0, rootCellSize)),
                        new Vector3(i * rootCellSize, j * rootCellSize, k * rootCellSize),
                        Vector3.zero,
                        WindProducerMode.Static
                    );

                    AddToCell(point);
                }
            }
        }

        Debug.Log("Cells: " + cells.CellCount());
        StartCoroutine(UpdateCells());
    }

    //Updates dynamic wind points for all cells in the wind field.
    private IEnumerator UpdateCells()
    {
        while (true)
        {
            cells.UpdateCells(dynamicProducers);
            //Debug.Log("dynamicProducers: " + string.Join(", ", dynamicProducers));
            yield return new WaitForSecondsRealtime(updateInterval);
        }
    }

    /*----PUBLIC FUNCTIONS----*/
    //Includes the given WindFieldPoint in the wind field: if dynamic, adds the point to the dynamic wind objects list and then to its corresponding cell;
    //if static, just adds the point to its cell (since static wind points are never updated, there is no need to keep track of them outside their cells) 
    public void Include(WF_WindProducer windProducer)
    {
        if (windProducer.mode == WindProducerMode.Dynamic) dynamicProducers.Add(windProducer);
        AddToCell(windProducer.GetWindFieldPoints());
    }

    //Adds a given WindFieldPoint to the cell corresponding to its position and depth, creating that cell and its parent(s) if they don't exist.
    //TODO: getting a new key each time is very inefficient compared to getting the deepest key initially and removing elements from that. 
    public void AddToCell(WF_WindPoint obj)
    {
        cells.AddToCell(obj);
    }

    //Adds given WindFieldPoints to their corresponding cells (creates new cell(s) if none exist at generated hash position(s))
    public void AddToCell(WF_WindPoint[] objs)
    {
        foreach (WF_WindPoint obj in objs) AddToCell(obj);
    }

    /*----GETTERS AND SETTERS----*/
    //Gets the wind vector at the given world position. If no cell exists at the given position, returns either (0, 0, 0) or the global wind vector, if using
    public Vector3 GetWind(Vector3 pos)
    {
        //If no root at this position, returns either the global wind vec or zero.
        Vector3 wind = useGlobalWind ? globalWind : Vector3.zero;

        if (addNoise)
        {
            Vector3 coords = pos;
            wind += WindNoise.Directional3D(coords, noiseFrequency, useTimeOffset ? Time.time : 0) * noiseStrength;
        }

        wind += cells.GetWind(pos);
        return wind;
    }

    public List<WF_Cell> GetCells()
    {
        return cells.GetCells();
    }

    //Get the world position of the cell with the given hash key. Note that this returns the
    //leastmost corner of the cell, not its centre (so a cell with bounds from (0,0,0) to (1,1,1)
    //would return (0,0,0), not (0.5,0.5,0.5))
    /*
    public Vector3 GetCellWorldPosition(WF_HashKey key)
    {
        Vector3Int[] k = key.GetKey();
        Vector3 worldPos = (Vector3)k[0] * rootCellSize;
        float cellSize = rootCellSize / 2;

        for (int i = 1; i < k.Length; i++)
        {
            worldPos += (Vector3)k[i] * cellSize;
            cellSize /= 2;
        }

        return worldPos;
    }

    //Get the world position of the centre of the cell with the given hash key.
    public Vector3 GetCellWorldPositionCentre(WF_HashKey key)
    {
        Vector3Int[] k = key.GetKey();
        Vector3 worldPos = ((Vector3)k[0] * rootCellSize);
        float cellSize = rootCellSize / 2;

        for (int i = 1; i < k.Length; i++)
        {
            worldPos += (Vector3)k[i] * cellSize;
            cellSize /= 2;
        }

        //add half of deepest cell size in each dimension to get centre of deepest cell
        return worldPos + new Vector3(cellSize, cellSize, cellSize);
    }
    */

    /* DEBUG FUNCTIONS */
    //Returns the world position and size of all cells in the wind field. I can only see this being used as a debug/visualisation helper
    public List<Tuple<Vector3, float>> DEBUG_GetCellsWorldPosAndSize()
    {
        return cells.DEBUG_GetCellsWorldPosAndSize();
    }

    //Returns the world positions of the centre of each cell.
    public List<Vector3> DEBUG_GetCellWorldPositionsCentre()
    {
        return cells.DEBUG_GetCellWorldPositionsCentre();
    }

}